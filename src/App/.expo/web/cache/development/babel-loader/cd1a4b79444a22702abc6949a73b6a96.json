{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nvar _jsxFileName = \"/home/kevin/Downloads/bobapp/node_modules/react-native-week-view/src/Events/Events.js\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React, { PureComponent } from 'react';\nimport PropTypes from 'prop-types';\nimport View from \"react-native-web/dist/exports/View\";\nimport TouchableWithoutFeedback from \"react-native-web/dist/exports/TouchableWithoutFeedback\";\nimport moment from 'moment';\nimport memoizeOne from 'memoize-one';\nimport Event from \"../Event/Event\";\nimport { TIME_LABEL_HEIGHT, CONTAINER_HEIGHT, CONTAINER_WIDTH, calculateDaysArray, DATE_STR_FORMAT, availableNumberOfDays } from \"../utils\";\nimport styles, { CONTENT_OFFSET } from \"./Events.styles\";\nvar MINUTES_IN_HOUR = 60;\nvar EVENT_HORIZONTAL_PADDING = 15;\nvar EVENTS_CONTAINER_WIDTH = CONTAINER_WIDTH - EVENT_HORIZONTAL_PADDING;\nvar MIN_ITEM_WIDTH = 4;\nvar ALLOW_OVERLAP_SECONDS = 2;\n\nvar areEventsOverlapped = function areEventsOverlapped(event1EndDate, event2StartDate) {\n  var endDate = moment(event1EndDate);\n  endDate.subtract(ALLOW_OVERLAP_SECONDS, 'seconds');\n  return endDate.isSameOrAfter(event2StartDate);\n};\n\nvar Events = function (_PureComponent) {\n  _inherits(Events, _PureComponent);\n\n  var _super = _createSuper(Events);\n\n  function Events() {\n    var _this;\n\n    _classCallCheck(this, Events);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _this.getStyleForEvent = function (item) {\n      var startDate = moment(item.startDate);\n      var startHours = startDate.hours();\n      var startMinutes = startDate.minutes();\n      var totalStartMinutes = startHours * MINUTES_IN_HOUR + startMinutes;\n\n      var top = _this.minutesToYDimension(totalStartMinutes);\n\n      var deltaMinutes = moment(item.endDate).diff(item.startDate, 'minutes');\n\n      var height = _this.minutesToYDimension(deltaMinutes);\n\n      var width = _this.getEventItemWidth();\n\n      return {\n        top: top + CONTENT_OFFSET,\n        left: 0,\n        height: height,\n        width: width\n      };\n    };\n\n    _this.addOverlappedToArray = function (baseArr, overlappedArr, itemWidth) {\n      if (!overlappedArr) return;\n      var nOverlapped = overlappedArr.length;\n\n      if (nOverlapped === 0) {\n        return;\n      }\n\n      if (nOverlapped === 1) {\n        baseArr.push(overlappedArr[0]);\n        return;\n      }\n\n      var nLanes;\n      var horizontalPadding;\n      var indexToLane;\n\n      if (nOverlapped === 2) {\n        nLanes = nOverlapped;\n        horizontalPadding = 3;\n\n        indexToLane = function indexToLane(index) {\n          return index;\n        };\n      } else {\n        var maxLanes = nOverlapped;\n        var latestByLane = {};\n        var laneByEvent = {};\n        overlappedArr.forEach(function (event, index) {\n          for (var lane = 0; lane < maxLanes; lane += 1) {\n            var lastEvtInLaneIndex = latestByLane[lane];\n            var lastEvtInLane = (lastEvtInLaneIndex || lastEvtInLaneIndex === 0) && overlappedArr[lastEvtInLaneIndex];\n\n            if (!lastEvtInLane || !areEventsOverlapped(lastEvtInLane.data.endDate, event.data.startDate)) {\n              latestByLane[lane] = index;\n              laneByEvent[index] = lane;\n              break;\n            }\n          }\n        });\n        nLanes = Object.keys(latestByLane).length;\n        horizontalPadding = 2;\n\n        indexToLane = function indexToLane(index) {\n          return laneByEvent[index];\n        };\n      }\n\n      var dividedWidth = itemWidth / nLanes;\n      var width = Math.max(dividedWidth - horizontalPadding, MIN_ITEM_WIDTH);\n      overlappedArr.forEach(function (eventWithStyle, index) {\n        var data = eventWithStyle.data,\n            style = eventWithStyle.style;\n        baseArr.push({\n          data: data,\n          style: _objectSpread(_objectSpread({}, style), {}, {\n            width: width,\n            left: dividedWidth * indexToLane(index)\n          })\n        });\n      });\n    };\n\n    _this.getEventsWithPosition = function (totalEvents) {\n      var regularItemWidth = _this.getEventItemWidth();\n\n      return totalEvents.map(function (events) {\n        var overlappedSoFar = [];\n        var lastDate = null;\n        var eventsWithStyle = events.reduce(function (eventsAcc, event) {\n          var style = _this.getStyleForEvent(event);\n\n          var eventWithStyle = {\n            data: event,\n            style: style\n          };\n\n          if (!lastDate || areEventsOverlapped(lastDate, event.startDate)) {\n            overlappedSoFar.push(eventWithStyle);\n            var endDate = moment(event.endDate);\n            lastDate = lastDate ? moment.max(endDate, lastDate) : endDate;\n          } else {\n            _this.addOverlappedToArray(eventsAcc, overlappedSoFar, regularItemWidth);\n\n            overlappedSoFar = [eventWithStyle];\n            lastDate = moment(event.endDate);\n          }\n\n          return eventsAcc;\n        }, []);\n\n        _this.addOverlappedToArray(eventsWithStyle, overlappedSoFar, regularItemWidth);\n\n        return eventsWithStyle;\n      });\n    };\n\n    _this.minutesToYDimension = function (minutes) {\n      var hoursInDisplay = _this.props.hoursInDisplay;\n      var minutesInDisplay = MINUTES_IN_HOUR * hoursInDisplay;\n      return minutes * CONTAINER_HEIGHT / minutesInDisplay;\n    };\n\n    _this.yToHour = function (y) {\n      var hoursInDisplay = _this.props.hoursInDisplay;\n      var hour = y * hoursInDisplay / CONTAINER_HEIGHT;\n      return hour;\n    };\n\n    _this.getEventItemWidth = function () {\n      var numberOfDays = _this.props.numberOfDays;\n      return EVENTS_CONTAINER_WIDTH / numberOfDays;\n    };\n\n    _this.processEvents = memoizeOne(function (eventsByDate, initialDate, numberOfDays, rightToLeft) {\n      var dates = calculateDaysArray(initialDate, numberOfDays, rightToLeft);\n      var totalEvents = dates.map(function (date) {\n        var dateStr = date.format(DATE_STR_FORMAT);\n        return eventsByDate[dateStr] || [];\n      });\n\n      var totalEventsWithPosition = _this.getEventsWithPosition(totalEvents);\n\n      return totalEventsWithPosition;\n    });\n\n    _this.onGridClick = function (event, dayIndex) {\n      var _this$props = _this.props,\n          initialDate = _this$props.initialDate,\n          onGridClick = _this$props.onGridClick;\n\n      if (!onGridClick) {\n        return;\n      }\n\n      var locationY = event.nativeEvent.locationY;\n      var hour = Math.floor(_this.yToHour(locationY - CONTENT_OFFSET));\n      var date = moment(initialDate).add(dayIndex, 'day').toDate();\n      onGridClick(event, hour, date);\n    };\n\n    return _this;\n  }\n\n  _createClass(Events, [{\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _this$props2 = this.props,\n          eventsByDate = _this$props2.eventsByDate,\n          initialDate = _this$props2.initialDate,\n          numberOfDays = _this$props2.numberOfDays,\n          times = _this$props2.times,\n          onEventPress = _this$props2.onEventPress,\n          eventContainerStyle = _this$props2.eventContainerStyle,\n          EventComponent = _this$props2.EventComponent,\n          rightToLeft = _this$props2.rightToLeft;\n      var totalEvents = this.processEvents(eventsByDate, initialDate, numberOfDays, rightToLeft);\n      return React.createElement(View, {\n        style: styles.container,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 218,\n          columnNumber: 7\n        }\n      }, times.map(function (time) {\n        return React.createElement(View, {\n          key: time,\n          style: [styles.timeRow, {\n            height: TIME_LABEL_HEIGHT\n          }],\n          __self: _this2,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 220,\n            columnNumber: 11\n          }\n        }, React.createElement(View, {\n          style: styles.timeLabelLine,\n          __self: _this2,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 224,\n            columnNumber: 13\n          }\n        }));\n      }), React.createElement(View, {\n        style: styles.events,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 227,\n          columnNumber: 9\n        }\n      }, totalEvents.map(function (eventsInSection, dayIndex) {\n        return React.createElement(TouchableWithoutFeedback, {\n          onPress: function onPress(e) {\n            return _this2.onGridClick(e, dayIndex);\n          },\n          key: dayIndex,\n          __self: _this2,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 229,\n            columnNumber: 13\n          }\n        }, React.createElement(View, {\n          style: styles.event,\n          __self: _this2,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 233,\n            columnNumber: 15\n          }\n        }, eventsInSection.map(function (item) {\n          return React.createElement(Event, {\n            key: item.data.id,\n            event: item.data,\n            position: item.style,\n            onPress: onEventPress,\n            EventComponent: EventComponent,\n            containerStyle: eventContainerStyle,\n            __self: _this2,\n            __source: {\n              fileName: _jsxFileName,\n              lineNumber: 235,\n              columnNumber: 19\n            }\n          });\n        })));\n      })));\n    }\n  }]);\n\n  return Events;\n}(PureComponent);\n\nEvents.propTypes = {\n  numberOfDays: PropTypes.oneOf(availableNumberOfDays).isRequired,\n  eventsByDate: PropTypes.objectOf(PropTypes.arrayOf(Event.propTypes.event)).isRequired,\n  initialDate: PropTypes.string.isRequired,\n  hoursInDisplay: PropTypes.number.isRequired,\n  times: PropTypes.arrayOf(PropTypes.string).isRequired,\n  onEventPress: PropTypes.func,\n  onGridClick: PropTypes.func,\n  eventContainerStyle: PropTypes.object,\n  EventComponent: PropTypes.elementType,\n  rightToLeft: PropTypes.bool\n};\nexport default Events;","map":{"version":3,"sources":["/home/kevin/Downloads/bobapp/node_modules/react-native-week-view/src/Events/Events.js"],"names":["React","PureComponent","PropTypes","moment","memoizeOne","Event","TIME_LABEL_HEIGHT","CONTAINER_HEIGHT","CONTAINER_WIDTH","calculateDaysArray","DATE_STR_FORMAT","availableNumberOfDays","styles","CONTENT_OFFSET","MINUTES_IN_HOUR","EVENT_HORIZONTAL_PADDING","EVENTS_CONTAINER_WIDTH","MIN_ITEM_WIDTH","ALLOW_OVERLAP_SECONDS","areEventsOverlapped","event1EndDate","event2StartDate","endDate","subtract","isSameOrAfter","Events","getStyleForEvent","item","startDate","startHours","hours","startMinutes","minutes","totalStartMinutes","top","minutesToYDimension","deltaMinutes","diff","height","width","getEventItemWidth","left","addOverlappedToArray","baseArr","overlappedArr","itemWidth","nOverlapped","length","push","nLanes","horizontalPadding","indexToLane","index","maxLanes","latestByLane","laneByEvent","forEach","event","lane","lastEvtInLaneIndex","lastEvtInLane","data","Object","keys","dividedWidth","Math","max","eventWithStyle","style","getEventsWithPosition","totalEvents","regularItemWidth","map","events","overlappedSoFar","lastDate","eventsWithStyle","reduce","eventsAcc","hoursInDisplay","props","minutesInDisplay","yToHour","y","hour","numberOfDays","processEvents","eventsByDate","initialDate","rightToLeft","dates","date","dateStr","format","totalEventsWithPosition","onGridClick","dayIndex","locationY","nativeEvent","floor","add","toDate","times","onEventPress","eventContainerStyle","EventComponent","container","time","timeRow","timeLabelLine","eventsInSection","e","id","propTypes","oneOf","isRequired","objectOf","arrayOf","string","number","func","object","elementType","bool"],"mappings":"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","sourcesContent":["import React, { PureComponent } from 'react';\nimport PropTypes from 'prop-types';\nimport { View, TouchableWithoutFeedback } from 'react-native';\nimport moment from 'moment';\nimport memoizeOne from 'memoize-one';\n\nimport Event from '../Event/Event';\nimport {\n  TIME_LABEL_HEIGHT,\n  CONTAINER_HEIGHT,\n  CONTAINER_WIDTH,\n  calculateDaysArray,\n  DATE_STR_FORMAT,\n  availableNumberOfDays,\n} from '../utils';\n\nimport styles, { CONTENT_OFFSET } from './Events.styles';\n\nconst MINUTES_IN_HOUR = 60;\nconst EVENT_HORIZONTAL_PADDING = 15;\nconst EVENTS_CONTAINER_WIDTH = CONTAINER_WIDTH - EVENT_HORIZONTAL_PADDING;\nconst MIN_ITEM_WIDTH = 4;\nconst ALLOW_OVERLAP_SECONDS = 2;\n\nconst areEventsOverlapped = (event1EndDate, event2StartDate) => {\n  const endDate = moment(event1EndDate);\n  endDate.subtract(ALLOW_OVERLAP_SECONDS, 'seconds');\n  return endDate.isSameOrAfter(event2StartDate);\n};\n\nclass Events extends PureComponent {\n  getStyleForEvent = (item) => {\n    const startDate = moment(item.startDate);\n    const startHours = startDate.hours();\n    const startMinutes = startDate.minutes();\n    const totalStartMinutes = startHours * MINUTES_IN_HOUR + startMinutes;\n    const top = this.minutesToYDimension(totalStartMinutes);\n    const deltaMinutes = moment(item.endDate).diff(item.startDate, 'minutes');\n    const height = this.minutesToYDimension(deltaMinutes);\n    const width = this.getEventItemWidth();\n\n    return {\n      top: top + CONTENT_OFFSET,\n      left: 0,\n      height,\n      width,\n    };\n  };\n\n  addOverlappedToArray = (baseArr, overlappedArr, itemWidth) => {\n    // Given an array of overlapped events (with style), modifies their style to overlap them\n    // and adds them to a (base) array of events.\n    if (!overlappedArr) return;\n\n    const nOverlapped = overlappedArr.length;\n    if (nOverlapped === 0) {\n      return;\n    }\n    if (nOverlapped === 1) {\n      baseArr.push(overlappedArr[0]);\n      return;\n    }\n\n    let nLanes;\n    let horizontalPadding;\n    let indexToLane;\n    if (nOverlapped === 2) {\n      nLanes = nOverlapped;\n      horizontalPadding = 3;\n      indexToLane = (index) => index;\n    } else {\n      // Distribute events in multiple lanes\n      const maxLanes = nOverlapped;\n      const latestByLane = {};\n      const laneByEvent = {};\n      overlappedArr.forEach((event, index) => {\n        for (let lane = 0; lane < maxLanes; lane += 1) {\n          const lastEvtInLaneIndex = latestByLane[lane];\n          const lastEvtInLane =\n            (lastEvtInLaneIndex || lastEvtInLaneIndex === 0) &&\n            overlappedArr[lastEvtInLaneIndex];\n          if (\n            !lastEvtInLane ||\n            !areEventsOverlapped(\n              lastEvtInLane.data.endDate,\n              event.data.startDate,\n            )\n          ) {\n            // Place in this lane\n            latestByLane[lane] = index;\n            laneByEvent[index] = lane;\n            break;\n          }\n        }\n      });\n\n      nLanes = Object.keys(latestByLane).length;\n      horizontalPadding = 2;\n      indexToLane = (index) => laneByEvent[index];\n    }\n    const dividedWidth = itemWidth / nLanes;\n    const width = Math.max(dividedWidth - horizontalPadding, MIN_ITEM_WIDTH);\n\n    overlappedArr.forEach((eventWithStyle, index) => {\n      const { data, style } = eventWithStyle;\n      baseArr.push({\n        data,\n        style: {\n          ...style,\n          width,\n          left: dividedWidth * indexToLane(index),\n        },\n      });\n    });\n  };\n\n  getEventsWithPosition = (totalEvents) => {\n    const regularItemWidth = this.getEventItemWidth();\n\n    return totalEvents.map((events) => {\n      let overlappedSoFar = []; // Store events overlapped until now\n      let lastDate = null;\n      const eventsWithStyle = events.reduce((eventsAcc, event) => {\n        const style = this.getStyleForEvent(event);\n        const eventWithStyle = {\n          data: event,\n          style,\n        };\n\n        if (!lastDate || areEventsOverlapped(lastDate, event.startDate)) {\n          overlappedSoFar.push(eventWithStyle);\n          const endDate = moment(event.endDate);\n          lastDate = lastDate ? moment.max(endDate, lastDate) : endDate;\n        } else {\n          this.addOverlappedToArray(\n            eventsAcc,\n            overlappedSoFar,\n            regularItemWidth,\n          );\n          overlappedSoFar = [eventWithStyle];\n          lastDate = moment(event.endDate);\n        }\n        return eventsAcc;\n      }, []);\n      this.addOverlappedToArray(\n        eventsWithStyle,\n        overlappedSoFar,\n        regularItemWidth,\n      );\n      return eventsWithStyle;\n    });\n  };\n\n  minutesToYDimension = (minutes) => {\n    const { hoursInDisplay } = this.props;\n    const minutesInDisplay = MINUTES_IN_HOUR * hoursInDisplay;\n    return (minutes * CONTAINER_HEIGHT) / minutesInDisplay;\n  };\n\n  yToHour = (y) => {\n    const { hoursInDisplay } = this.props;\n    const hour = (y * hoursInDisplay) / CONTAINER_HEIGHT;\n    return hour;\n  };\n\n  getEventItemWidth = () => {\n    const { numberOfDays } = this.props;\n    return EVENTS_CONTAINER_WIDTH / numberOfDays;\n  };\n\n  processEvents = memoizeOne(\n    (eventsByDate, initialDate, numberOfDays, rightToLeft) => {\n      // totalEvents stores events in each day of numberOfDays\n      // example: [[event1, event2], [event3, event4], [event5]], each child array\n      // is events for specific day in range\n      const dates = calculateDaysArray(initialDate, numberOfDays, rightToLeft);\n      const totalEvents = dates.map((date) => {\n        const dateStr = date.format(DATE_STR_FORMAT);\n        return eventsByDate[dateStr] || [];\n      });\n      const totalEventsWithPosition = this.getEventsWithPosition(totalEvents);\n      return totalEventsWithPosition;\n    },\n  );\n\n  onGridClick = (event, dayIndex) => {\n    const { initialDate, onGridClick } = this.props;\n    if (!onGridClick) {\n      return;\n    }\n    const { locationY } = event.nativeEvent;\n    const hour = Math.floor(this.yToHour(locationY - CONTENT_OFFSET));\n\n    const date = moment(initialDate).add(dayIndex, 'day').toDate();\n\n    onGridClick(event, hour, date);\n  };\n\n  render() {\n    const {\n      eventsByDate,\n      initialDate,\n      numberOfDays,\n      times,\n      onEventPress,\n      eventContainerStyle,\n      EventComponent,\n      rightToLeft,\n    } = this.props;\n    const totalEvents = this.processEvents(\n      eventsByDate,\n      initialDate,\n      numberOfDays,\n      rightToLeft,\n    );\n\n    return (\n      <View style={styles.container}>\n        {times.map((time) => (\n          <View\n            key={time}\n            style={[styles.timeRow, { height: TIME_LABEL_HEIGHT }]}\n          >\n            <View style={styles.timeLabelLine} />\n          </View>\n        ))}\n        <View style={styles.events}>\n          {totalEvents.map((eventsInSection, dayIndex) => (\n            <TouchableWithoutFeedback\n              onPress={(e) => this.onGridClick(e, dayIndex)}\n              key={dayIndex}\n            >\n              <View style={styles.event}>\n                {eventsInSection.map((item) => (\n                  <Event\n                    key={item.data.id}\n                    event={item.data}\n                    position={item.style}\n                    onPress={onEventPress}\n                    EventComponent={EventComponent}\n                    containerStyle={eventContainerStyle}\n                  />\n                ))}\n              </View>\n            </TouchableWithoutFeedback>\n          ))}\n        </View>\n      </View>\n    );\n  }\n}\n\nEvents.propTypes = {\n  numberOfDays: PropTypes.oneOf(availableNumberOfDays).isRequired,\n  eventsByDate: PropTypes.objectOf(PropTypes.arrayOf(Event.propTypes.event))\n    .isRequired,\n  initialDate: PropTypes.string.isRequired,\n  hoursInDisplay: PropTypes.number.isRequired,\n  times: PropTypes.arrayOf(PropTypes.string).isRequired,\n  onEventPress: PropTypes.func,\n  onGridClick: PropTypes.func,\n  eventContainerStyle: PropTypes.object,\n  EventComponent: PropTypes.elementType,\n  rightToLeft: PropTypes.bool,\n};\n\nexport default Events;\n"]},"metadata":{},"sourceType":"module"}